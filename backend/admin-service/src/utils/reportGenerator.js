// src/utils/reportGenerator.js
import { logger } from '@ev-coownership/shared';
import PDFDocument from 'pdfkit';
import ExcelJS from 'exceljs';

export class ReportGenerator {
  static async generatePDFReport(reportData, options = {}) {
    return new Promise((resolve, reject) => {
      try {
        const doc = new PDFDocument();
        const chunks = [];
        
        doc.on('data', (chunk) => chunks.push(chunk));
        doc.on('end', () => resolve(Buffer.concat(chunks)));
        doc.on('error', reject);

        // Report header
        doc.fontSize(20)
           .text(options.title || 'EV Co-ownership System Report', 100, 100);
        
        doc.fontSize(12)
           .text(`Generated on: ${new Date().toLocaleDateString()}`, 100, 130)
           .text(`Period: ${options.period || 'N/A'}`, 100, 150)
           .text(`Generated by: ${options.generatedBy || 'System'}`, 100, 170);

        // Add content based on report type
        this.addPDFContent(doc, reportData, options);

        doc.end();
      } catch (error) {
        logger.error('Failed to generate PDF report', { error: error.message });
        reject(error);
      }
    });
  }

  static addPDFContent(doc, reportData, options) {
    let yPosition = 220;

    switch (options.type) {
      case 'user_analytics':
        this.addUserAnalyticsPDF(doc, reportData, yPosition);
        break;
      case 'revenue_report':
        this.addRevenueReportPDF(doc, reportData, yPosition);
        break;
      case 'dispute_summary':
        this.addDisputeSummaryPDF(doc, reportData, yPosition);
        break;
      case 'dispute_detail':
        this.addDisputeDetailPDF(doc, reportData, yPosition);
        break;
      case 'kyc_status':
        this.addKYCStatusPDF(doc, reportData, yPosition);
        break;
      default:
        this.addGenericReportPDF(doc, reportData, yPosition);
    }
  }

  // Safely flatten objects to key/value pairs without blowing the stack on circular refs
  static flattenObjectSafe(obj) {
    const result = {};
    const seen = new WeakSet();

    function helper(value, prefix) {
      if (value === null || typeof value !== 'object') {
        result[prefix] = value;
        return;
      }

      if (seen.has(value)) {
        result[prefix] = '[Circular]';
        return;
      }
      seen.add(value);

      if (Array.isArray(value)) {
        value.forEach((item, idx) => {
          helper(item, `${prefix}[${idx}]`);
        });
        return;
      }

      Object.keys(value).forEach((key) => {
        const v = value[key];
        const newKey = prefix ? `${prefix}.${key}` : key;
        if (v !== null && typeof v === 'object') {
          helper(v, newKey);
        } else {
          result[newKey] = v;
        }
      });
    }

    helper(obj, '');
    // Remove empty-prefix keys (root-level assigned to '')
    if (Object.prototype.hasOwnProperty.call(result, '')) {
      const val = result[''];
      delete result[''];
      if (typeof val === 'object' && val !== null) {
        Object.assign(result, val);
      } else {
        result['value'] = val;
      }
    }

    return result;
  }

  static addDisputeDetailPDF(doc, dispute, startY) {
    let y = startY;
    doc.fontSize(18).text(`Dispute ${dispute.disputeNumber || dispute.id}`, 100, y);
    y += 30;

    doc.fontSize(12)
       .text(`Title: ${dispute.title || '-'}`, 100, y);
    y += 20;
    doc.text(`Status: ${dispute.status || '-'}`, 100, y);
    y += 18;
    doc.text(`Priority: ${dispute.priority || '-'}`, 100, y);
    y += 18;
    doc.text(`Filed by: ${dispute.filedBy || dispute.filed_by || '-'}`, 100, y);
    y += 18;
    doc.text(`Against: ${dispute.againstUser || dispute.against_user || '-'}`, 100, y);
    y += 18;
    doc.text(`Group: ${dispute.groupId || dispute.group_id || '-'}`, 100, y);
    y += 18;
    if (dispute.assignedStaff) {
      doc.text(`Assigned to: ${dispute.assignedStaff.employeeId || dispute.assignedStaff.id} — ${dispute.assignedStaff.position || ''}`, 100, y);
      y += 18;
    }
    if (dispute.resolution) {
      doc.text(`Resolution: ${dispute.resolution}`, 100, y);
      y += 20;
    }

    // Messages
    if (Array.isArray(dispute.messages) && dispute.messages.length) {
      if (y > 700) { doc.addPage(); y = 100; }
      doc.fontSize(14).text('Messages', 100, y);
      y += 24;
      dispute.messages.forEach((m) => {
        if (y > 720) { doc.addPage(); y = 100; }
        const sender = m.user || m.senderName || m.senderId || m.senderId || 'Unknown';
        const time = m.time || m.createdAt || m.updatedAt || '';
        doc.fontSize(10).text(`${sender} — ${time}`, 120, y);
        y += 14;
        doc.fontSize(11).text(`${m.message}`, 120, y, { width: 380 });
        y += 28;
      });
    }
  }

  static addUserAnalyticsPDF(doc, data, startY) {
    let y = startY;
    
    doc.fontSize(16).text('User Analytics Summary', 100, y);
    y += 40;

    // Summary stats
    if (data.summary) {
      doc.fontSize(12)
         .text(`Total Users: ${data.summary.totalUsers || 0}`, 100, y)
         .text(`Active Users: ${data.summary.activeUsers || 0}`, 100, y + 20)
         .text(`Growth Rate: ${data.summary.growthRate || 0}%`, 100, y + 40)
         .text(`Retention Rate: ${data.summary.retentionRate || 0}%`, 100, y + 60);
      y += 100;
    }

    // Trends table
    if (data.trends && data.trends.registrations) {
      doc.fontSize(14).text('Registration Trends', 100, y);
      y += 30;

      data.trends.registrations.forEach((trend, index) => {
        if (y > 700) {
          doc.addPage();
          y = 100;
        }
        doc.fontSize(10)
           .text(`${trend.date || trend.period}: ${trend.count} users`, 120, y);
        y += 20;
      });
    }
  }

  static addRevenueReportPDF(doc, data, startY) {
    let y = startY;
    
    doc.fontSize(16).text('Revenue Report', 100, y);
    y += 40;

    if (data.summary) {
      doc.fontSize(12)
         .text(`Total Revenue: ${this.formatCurrency(data.summary.totalRevenue)}`, 100, y)
         .text(`Average Transaction: ${this.formatCurrency(data.summary.averageTransaction)}`, 100, y + 20)
         .text(`Transaction Count: ${data.summary.transactionCount || 0}`, 100, y + 40)
         .text(`Growth Rate: ${data.summary.growthRate || 0}%`, 100, y + 60);
      y += 100;
    }

    if (data.breakdown && data.breakdown.byService) {
      doc.fontSize(14).text('Revenue by Service', 100, y);
      y += 30;

      Object.entries(data.breakdown.byService).forEach(([service, amount]) => {
        if (y > 700) {
          doc.addPage();
          y = 100;
        }
        doc.fontSize(10)
           .text(`${this.capitalizeFirst(service)}: ${this.formatCurrency(amount)}`, 120, y);
        y += 20;
      });
    }
  }

  static addDisputeSummaryPDF(doc, data, startY) {
    let y = startY;
    
    doc.fontSize(16).text('Dispute Summary Report', 100, y);
    y += 40;

    doc.fontSize(12)
       .text(`Total Disputes: ${data.total || 0}`, 100, y)
       .text(`Open Disputes: ${data.open || 0}`, 100, y + 20)
       .text(`Resolved Disputes: ${data.resolved || 0}`, 100, y + 40)
       .text(`Resolution Rate: ${data.resolutionRate || 0}%`, 100, y + 60)
       .text(`Average Resolution Time: ${data.averageResolutionTime || 0} hours`, 100, y + 80);
  }

  static addKYCStatusPDF(doc, data, startY) {
    let y = startY;
    
    doc.fontSize(16).text('KYC Status Report', 100, y);
    y += 40;

    doc.fontSize(12)
       .text(`Total Submissions: ${data.total || 0}`, 100, y)
       .text(`Pending: ${data.pending || 0}`, 100, y + 20)
       .text(`Approved: ${data.approved || 0}`, 100, y + 40)
       .text(`Rejected: ${data.byStatus?.rejected || 0}`, 100, y + 60)
       .text(`Rejection Rate: ${data.rejectionRate || 0}%`, 100, y + 80)
       .text(`Average Processing Time: ${data.averageProcessingTime || 0} hours`, 100, y + 100);
  }

  static addGenericReportPDF(doc, data, startY) {
    let y = startY;
    
    doc.fontSize(16).text('System Report', 100, y);
    y += 40;

    // Safely flatten the object (handles circular refs)
    const flattened = this.flattenObjectSafe(data);
    
    Object.entries(flattened).forEach(([key, value]) => {
      if (y > 700) {
        doc.addPage();
        y = 100;
      }
      doc.fontSize(10)
         .text(`${key}: ${value}`, 100, y);
      y += 15;
    });
  }

  static async generateExcelReport(reportData, options = {}) {
    try {
      const workbook = new ExcelJS.Workbook();
      const worksheet = workbook.addWorksheet(options.title || 'Report');

      // Add header
      worksheet.mergeCells('A1:D1');
      worksheet.getCell('A1').value = options.title || 'EV Co-ownership System Report';
      worksheet.getCell('A1').font = { size: 16, bold: true };
      
      worksheet.getCell('A2').value = `Generated on: ${new Date().toLocaleDateString()}`;
      worksheet.getCell('A3').value = `Period: ${options.period || 'N/A'}`;
      worksheet.getCell('A4').value = `Generated by: ${options.generatedBy || 'System'}`;

      // Add content based on report type
      await this.addExcelContent(worksheet, reportData, options);

      return await workbook.xlsx.writeBuffer();
    } catch (error) {
      logger.error('Failed to generate Excel report', { error: error.message });
      throw error;
    }
  }

  static async addExcelContent(worksheet, reportData, options) {
    let currentRow = 6;

    switch (options.type) {
      case 'user_analytics':
        await this.addUserAnalyticsExcel(worksheet, reportData, currentRow);
        break;
      case 'revenue_report':
        await this.addRevenueReportExcel(worksheet, reportData, currentRow);
        break;
      case 'dispute_summary':
        await this.addDisputeSummaryExcel(worksheet, reportData, currentRow);
        break;
      case 'kyc_status':
        await this.addKYCStatusExcel(worksheet, reportData, currentRow);
        break;
      default:
        await this.addGenericReportExcel(worksheet, reportData, currentRow);
    }
  }

  static async addUserAnalyticsExcel(worksheet, data, startRow) {
    let row = startRow;

    // Summary section
    worksheet.mergeCells(`A${row}:B${row}`);
    worksheet.getCell(`A${row}`).value = 'User Analytics Summary';
    worksheet.getCell(`A${row}`).font = { bold: true };
    row++;

    if (data.summary) {
      const summaryData = [
        ['Total Users', data.summary.totalUsers || 0],
        ['Active Users', data.summary.activeUsers || 0],
        ['Growth Rate', `${data.summary.growthRate || 0}%`],
        ['Retention Rate', `${data.summary.retentionRate || 0}%`]
      ];

      summaryData.forEach(([label, value], index) => {
        worksheet.getCell(`A${row + index}`).value = label;
        worksheet.getCell(`B${row + index}`).value = value;
      });
      row += summaryData.length + 2;
    }

    // Trends section
    if (data.trends && data.trends.registrations) {
      worksheet.mergeCells(`A${row}:C${row}`);
      worksheet.getCell(`A${row}`).value = 'Registration Trends';
      worksheet.getCell(`A${row}`).font = { bold: true };
      row++;

      // Headers
      worksheet.getCell(`A${row}`).value = 'Date';
      worksheet.getCell(`B${row}`).value = 'Registrations';
      worksheet.getCell(`C${row}`).value = 'Unique Users';
      row++;

      // Data
      data.trends.registrations.forEach(trend => {
        worksheet.getCell(`A${row}`).value = trend.date || trend.period;
        worksheet.getCell(`B${row}`).value = trend.count;
        worksheet.getCell(`C${row}`).value = trend.unique_users_count || 0;
        row++;
      });
    }
  }

  static async addRevenueReportExcel(worksheet, data, startRow) {
    let row = startRow;

    worksheet.mergeCells(`A${row}:B${row}`);
    worksheet.getCell(`A${row}`).value = 'Revenue Report';
    worksheet.getCell(`A${row}`).font = { bold: true };
    row++;

    if (data.summary) {
      const summaryData = [
        ['Total Revenue', this.formatCurrency(data.summary.totalRevenue)],
        ['Average Transaction', this.formatCurrency(data.summary.averageTransaction)],
        ['Transaction Count', data.summary.transactionCount || 0],
        ['Growth Rate', `${data.summary.growthRate || 0}%`]
      ];

      summaryData.forEach(([label, value], index) => {
        worksheet.getCell(`A${row + index}`).value = label;
        worksheet.getCell(`B${row + index}`).value = value;
      });
      row += summaryData.length + 2;
    }

    if (data.breakdown && data.breakdown.byService) {
      worksheet.mergeCells(`A${row}:B${row}`);
      worksheet.getCell(`A${row}`).value = 'Revenue by Service';
      worksheet.getCell(`A${row}`).font = { bold: true };
      row++;

      Object.entries(data.breakdown.byService).forEach(([service, amount]) => {
        worksheet.getCell(`A${row}`).value = this.capitalizeFirst(service);
        worksheet.getCell(`B${row}`).value = this.formatCurrency(amount);
        row++;
      });
    }
  }

  static async addDisputeSummaryExcel(worksheet, data, startRow) {
    let row = startRow;

    const disputeData = [
      ['Total Disputes', data.total || 0],
      ['Open Disputes', data.open || 0],
      ['Resolved Disputes', data.resolved || 0],
      ['Resolution Rate', `${data.resolutionRate || 0}%`],
      ['Average Resolution Time', `${data.averageResolutionTime || 0} hours`]
    ];

    worksheet.mergeCells(`A${row}:B${row}`);
    worksheet.getCell(`A${row}`).value = 'Dispute Summary';
    worksheet.getCell(`A${row}`).font = { bold: true };
    row++;

    disputeData.forEach(([label, value], index) => {
      worksheet.getCell(`A${row + index}`).value = label;
      worksheet.getCell(`B${row + index}`).value = value;
    });
  }

  static async addKYCStatusExcel(worksheet, data, startRow) {
    let row = startRow;

    const kycData = [
      ['Total Submissions', data.total || 0],
      ['Pending', data.pending || 0],
      ['Approved', data.approved || 0],
      ['Rejected', data.byStatus?.rejected || 0],
      ['Rejection Rate', `${data.rejectionRate || 0}%`],
      ['Average Processing Time', `${data.averageProcessingTime || 0} hours`]
    ];

    worksheet.mergeCells(`A${row}:B${row}`);
    worksheet.getCell(`A${row}`).value = 'KYC Status Report';
    worksheet.getCell(`A${row}`).font = { bold: true };
    row++;

    kycData.forEach(([label, value], index) => {
      worksheet.getCell(`A${row + index}`).value = label;
      worksheet.getCell(`B${row + index}`).value = value;
    });
  }

  static async addGenericReportExcel(worksheet, data, startRow) {
    let row = startRow;

    const flattened = this.flattenObjectSafe(data);
    
    worksheet.mergeCells(`A${row}:B${row}`);
    worksheet.getCell(`A${row}`).value = 'System Report';
    worksheet.getCell(`A${row}`).font = { bold: true };
    row++;

    Object.entries(flattened).forEach(([key, value]) => {
      worksheet.getCell(`A${row}`).value = key;
      worksheet.getCell(`B${row}`).value = value;
      row++;
    });
  }

  static formatCurrency(amount) {
    return new Intl.NumberFormat('vi-VN', {
      style: 'currency',
      currency: 'VND'
    }).format(amount);
  }

  static capitalizeFirst(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }

  static async generateReport(reportData, format = 'pdf', options = {}) {
    try {
      switch (format.toLowerCase()) {
        case 'pdf':
          return await this.generatePDFReport(reportData, options);
        case 'excel':
        case 'xlsx':
          return await this.generateExcelReport(reportData, options);
        case 'json':
          return Buffer.from(JSON.stringify(reportData, null, 2));
        case 'csv':
          return this.convertToCSV(reportData);
        default:
          throw new Error(`Unsupported format: ${format}`);
      }
    } catch (error) {
      logger.error('Failed to generate report', { 
        error: error.message,
        format,
        type: options.type 
      });
      throw error;
    }
  }

  static convertToCSV(data) {
    const flattened = this.flattenObjectSafe(data);
    const headers = Object.keys(flattened).join(',');
    const values = Object.values(flattened).map(val => 
      typeof val === 'string' ? `"${val.replace(/"/g, '""')}"` : val
    ).join(',');

    return `${headers}\n${values}`;
  }

  static getSupportedFormats() {
    return ['pdf', 'excel', 'xlsx', 'json', 'csv'];
  }

  static getMimeType(format) {
    const mimeTypes = {
      pdf: 'application/pdf',
      excel: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      xlsx: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      json: 'application/json',
      csv: 'text/csv'
    };
    
    return mimeTypes[format.toLowerCase()] || 'application/octet-stream';
  }

  static getFileExtension(format) {
    const extensions = {
      pdf: 'pdf',
      excel: 'xlsx',
      xlsx: 'xlsx',
      json: 'json',
      csv: 'csv'
    };
    
    return extensions[format.toLowerCase()] || 'txt';
  }
}

export default ReportGenerator;